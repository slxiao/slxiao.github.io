---
layout: post
title:  "掀起TA的盖头来：闲聊软件测试自动化"
date:   2017-04-18 10:00:00 +0800
categories: jekyll update
---

<link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css">

<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
 $(document).ready(function(){
      $("h2,h3,h4,h5,h6").each(function(i,item){
        var tag = $(item).get(0).localName;
        var className = $(item).get(0).className;
        if (className != "footer-heading"){
            $(item).attr("id","wow"+i);
            $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>');
            $(".newh2").css("margin-left",0);
            $(".newh3").css("margin-left",20);
            $(".newh4").css("margin-left",40);
            $(".newh5").css("margin-left",60);
            $(".newh6").css("margin-left",80);
      }});
 });
</script>
<div id="category"></div>

# 掀起TA的盖头来：闲聊软件测试自动化

 > *笔者按： 在学生时代，参与过一些软件项目，也开发过一些模块，但对软件测试几乎一片空白、没有任何概念。进入工业界后，有幸在软件测试部门工作近两年。在实践中，深深体会到软件测试之于软件质量的重要性。测试自动化(Test Automation, TA)作为软件测试的发展方向，日益受到重视。笔者在对TA的学习、实践、交流中，逐渐形成了一些关于TA的认识和思考。在此稍作整理，分享给大家。文章纯属一家之言，难免有纰漏甚至谬误之处，还望读者批判性地看。*

## TA的好处我们知道多少？
测试自动化(Test Automation, 简称TA)是软件工程中的一个名词。维基百科对[TA](https://en.wikipedia.org/wiki/Test_automation)的定义是：

> 测试自动化就是用特定的软件去控制测试步骤的执行并且对测试结果和期望结果进行比较。

与TA相对应的是传统的手动测试(Manual Test)，即人工地去执行测试和比较测试结果。根据定义可知，TA就是把本来需要人去完成的测试任务，以软件(即程序)的形式，交给计算机去完成。为什么要以软件的形式？因为这是计算机能够理解的。对于软件测试来说，TA是典型的"机器换人"，是一个重大的技术变革。那么，具体来说，这种变革到底能够带来什么好处呢？

### 提升测试效率
所谓效率提升，本质上就是生产力的提高。对此，我们从多个角度进行理解：

- **单次测试的时间消耗大大减少**。测试工作通常包含一系列顺序执行的测试步骤。计算机不仅执行单个测试步骤更快，而且步骤与步骤之间的切换也是瞬时的。如果由人工执行，不仅执行单个步骤更慢，而且测试步骤之间的转换也会存在明显延迟。另外，对于计算机来说，我们很容易通过硬件能力的扩展(多核、多机器)，来让单个测试步骤执行得更快。但是对于人工来说，我们却无法通过增加人数来达到同样的目的。

- **在相同时间内，可以执行更多的测试**。我们知道，人要下班，而计算机一直在岗；人要休息，而计算机不知疲倦。计算机可以在深夜、在周末、在任何时候重复执行测试，而人却无法做到。相同的时间周期内，计算机重复执行测试的次数是人工无法比拟的。另一方面，计算机能够并行地执行多种测试工作，而人却很难同时开展两项不同的测试。

- **通过快速和重复的测试，有利于及早和更多地发现产品问题**。事实上，一切测试工作的出发点和落脚点都在于更快、更多地发现软件问题(即Bug，下同)。测试执行得越快，发现问题的时间就越早，软件开发人员经历的反馈时间就越短。这将有利于他们快速地定位问题和解决问题。另一方面，由于计算机很容易重复地执行测试，我们有可能发现(以及复现，Reproduce)更多偶现的(Occasional)软件问题。偶现问题通常很难由手动测试发现，而问题一旦漏到客户那里，有可能产生严重的后果。
### 承担特定测试
有些测试工作，人工很难、甚至几乎无法完成，从而只能由计算机承担。比如说性能测试(Performance Testing)，我们希望测试软件在大用户量或高并发量下的性能指标。在实际中，我们几乎无法去构造成千上万用户使用产品的测试场景。这时，我们可以用计算机来模拟这样的场景。通常，单台计算机就能够完成模拟成千上万用户的任务。又比如压力测试(Stress Testing)，我们希望测试软件在长时期、不间断运行时的性能变化。这时，几乎不可能使用人力去持续不断地监测软件的运行状态，而计算机(例如一个简单的脚本程序)就能够很好地承担这样的工作。
### 测试工作全过程自动化
一项完整的软件测试工作，包含: (1) 设计并实现测试用例(即Case，下同) (2) 部署和升级被测软件 (3) 执行测试用例 (4) 收集各种软件日志 (5)分析并反馈测试结果等步骤。其中，除了第(1)步外，其他几步均是高频工作，通常是每一次软件迭代都需要做的事情。狭义的TA，实际上仅仅是第(3)步，即测试执行层面的自动化。仅仅单个环节的自动化，对于测试工作整体效率的提升是有限的，因为其他步骤可能成为瓶颈。事实上，在测试执行自动化的基础上，将测试工作的其他高频步骤，例如升级被测软件、收集软件日志、反馈测试结果等，也以自动化的形式实现，是一件水到渠成的事情。将这些繁琐的、重复的、技术含量低的操作交给计算机去做，不仅进一步提升测试效率，缩短测试反馈时间，而且能够解放测试工程师，让其把更多的精力投入到设计并实现更好的测试Case、软件Bug定位和分析等更有挑战性的工作上。而这部分工作，通常是计算机难以胜任的。一般来说，**能让计算机做的就不要由人来做；人作为比计算机更宝贵的资源，应当去做计算机无法或很难胜任的事情**。

### 测试进入软件CI

现代软件开发，越来越强调以增量开发和快速迭代为特征的[敏捷模式](https://en.wikipedia.org/wiki/Scrum_(software_development))。在实际操作中，开发人员会频繁提交代码。每次代码的提交，都会自动触发软件持续集成([Continuous Integration](https://en.wikipedia.org/wiki/Continuous_integration), CI )系统的运行。CI在拿到软件代码的改动后，会自动触发一系列工作，例如静态检查代码、运行单元测试用例、编包等。CI系统高速、并行地运转着。单元测试通常由开发人员自己完成，并且以代码的形式存在，天然就是"自动化的"。而后续的功能、性能、集成等方面的测试，通常是在CI发布软件包之后，才开始以某种形式介入，是低速、串行地运转着。如果后续的测试能够实现自动化，那么也可以进入CI系统，成为CI的一部分。**测试进入软件CI**带来的好处可以从多方面解读：

- **助力[ATDD](https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development)(Acceptance Test Driven Development)思想落地**。如果说测试驱动开发([TDD](https://en.wikipedia.org/wiki/Test-driven_development))只是软件开发内部的实践(Practice)，那么验收性测试驱动开发(ATDD)则是业务、开发和测试三方合作下的实践，更有利于确保软件的实现符合产品的需求。具体来说，软件开发的完成应以**验收性测试Case**通过为标准。在新功能(Feature)开发阶段，验收性TA Case完全可以早于软件代码准备好(Ready)。每次软件代码的提交，均会**自动触发**对应TA Case的运行。TA Case通过了，软件的开发才算完成。如果TA Case自身存在问题，那么也可以像修改软件代码一样通过版本控制工具(例如[git](https://git-scm.com/))快速地修改、提交和生效。TA Case一旦通过，软件开发工作和对应的测试工作便同步完成。每一个新Feature完成，对应的TA Case便会加入TA的回归测试集(Regression Pool)。

- **确保后期代码改动不破坏已有功能**。软件代码的改动是一个高频率的事情。实现新的需求、修复软件Bug、重构等，都会造成代码的改动。那么，如何确保每次改动都不破坏已有的功能？在CI系统中，每次代码提交，自动触发TA回归测试集中所有Case的运行。只有所有的Case都通过了，这次代码提交才被认为是有效的，才能被合进代码的主分支(Master)。在软件功能一个接着一个完成的同时，回归测试集也相应地逐步扩大。**回归测试集的执行贯穿于软件开发的整个过程**，而不是等到软件开发全部结束后，再去做回归测试。在笔者当前参与的软件项目中，软件的功能测试实现了自动化，并且从第一个功能点开始，就进入了CI系统。据统计，功能测试回归集平均每个工作日在CI中被执行200多次，一个月内能达到5000次。这样的回归强度是手动测试时代完全不可想象的。

- **开发和测试通过CI实现高度协同工作**。开发和测试之间的"相爱相杀"，是软件公司一个永恒的话题(本文不展开)。**测试进入软件CI**为开发和测试人员提供了一种全新的工作模式。在实践中，开发和测试人员在同一个软件仓库，甚至在同一个分支上协同工作。开发人员实现产品代码(SW Code)，测试人员实现测试代码(Test Code)。任何一方做出改动，CI系统会自动进行验证，并将验证结果反馈给相关人员。这种在线的、同步的工作模式，实现了软件开发和测试验证的"**共振**"。

- **进一步完善CI系统**。软件的质量，最终是由用户来评判。CI系统完不完善，取决于自身与最终用户之间的距离。笔者认为，CI系统应该是**面向交付**的。从结果上看，CI输出的软件包应当以可供用户使用为目标。因此，CI应该尽可能地将软件开发之后的各个测试和验证阶段纳入进来，以进一步完善自身。TA，恰恰为测试进入CI提供了必要的前提条件。

## TA的实践中我们有哪些困惑？
我们看到，TA不仅提升了软件测试的生产力，而且改进了软件工程中的生产关系(对开发和CI等带来了积极变化)。那么，有什么理由不去推广TA呢？是的，在软件测试界，TA受到了重视。虽然很多测试人员未必能全面了解TA的诸多好处，但其实现TA的愿望普遍是强烈的。我们看到，在许多软件项目中，TA已经或正在被实践着。但是，实践的效果如何？TA是否给个人、部门、公司带来了期望中的收益？据了解，很多时候答案是否定的。在TA上投入不低，但是似乎收效不高。对TA产生质疑、甚至摒弃的声音也部分存在。那么，对于TA，人们到底有哪些困惑呢？
### TA收益之惑
一切软件测试工作都是为发现软件问题、提升软件质量而存在的，TA也不例外。对于TA的收益，一个最直接的衡量指标就是通过自动化测试所发现的软件问题的数量。如果(1)TA无法有效地发现问题，或者(2)TA发现了很多问题，但是经过分析，这些问题许多都不是软件问题，而是其他类型的问题，那么TA的收益就会低。不仅开发人员，甚至测试人员自身都会对TA形成负面评价。以笔者负责过的公司某款产品的自动化测试为例。一共5条测试线(Test Line)，分别对应5种不同的产品配置。每条测试线运行相同功能的19个TA  Case。每条测试线在每晚定时从CI系统获取一个或多个当天的软件包，升级测试环境，然后重复执行10次回归测试。笔者每天的工作是对前一天晚上执行的50次测试结果进行分析，发现问题，对问题进行跟踪处理，并撰写测试报告。为期3个月，总共测试了160多个软件包，执行了4000余次回归。经过对87份测试日报(Daily Report)和14份周报(Weekly Report)的统计分析，三个月内，**一共发现了99个问题，其中有25个是软件问题，57个是测试线问题，还有17个问题无法归类**。我们可以看到：

- **发现的测试线问题太多，占比接近60%**。所谓测试线问题，就是测试自身的问题。 测试自身问题的来源五花八门，包括测试Case本身、测试Case调用的底层TA库、测试环境中的外部模块(第三方硬件、网络设备、操作系统)、各种人为的误操作等等。为了发现被测软件的问题、检验被测软件的质量，我们投入许多人力物力，来搭建自动化的测试系统。结果事与愿违，我们发现的问题竟然大多数是测试系统自身的问题。这完全是本末倒置，无法让人接受。

- **尽管发现了25个软件问题，但问题的分析和跟踪并不彻底**。5条测试线持续运行3个月，值得欣慰的收获就是发现了25个软件问题。但是，对于测试人员来说，仅仅发现问题是远远不够的。我们还需要对问题的现象和原因进行深入分析，对问题的状态进行紧密跟踪，从而举一反三。但是，由于我们发现了太多的非软件问题，仅仅分析和解决这些非软件问题就要花费测试人员大量的时间和精力。总的资源受限，投入到非软件问题上的资源越多，投入到软件问题上的资源就越少。事实上，虽然发现了25个软件问题，但真正有效的软件问题并没有25个。一些软件问题并没有得到深入地分析。在一段时间内没有复现，便被关闭(Close)了。事实上，软件的隐患或许并没有根除，问题仍然有可能在未来的某个时候再次出现。另外，那17个无法归类的问题也多数属于这种类型，问题的根源对于测试人员来说是未知的。
### TA维护之痛
TA本质上是一种软件活动(Software Activity)。任何一项软件活动都离不开**维护**(Maintenance)。通常来说，维护是一种创造的实际价值非常有限，但却要消耗一定资源的事情。维护成本的高低，直接决定于软件工作的质量。TA的维护成本过高，可能体现在多个方面：

- **TA测试环境的维护成本过高**。相比手动测试环境，TA测试环境通常要更加复杂一些。TA是用测试软件去验证被测软件。因此我们至少需要增加一个设备(或占用一个已有设备的部分空间)来运行测试软件。通常，
    > TA测试环境的维护成本，与测试环境的复杂度成正比。

    如果TA测试环境过于复杂，那么其维护成本一定不会低。测试环境中任何一个设备不稳定，都会造成整个测试环境的不稳定。自动化的隐含意义就是"无人值守"，而"无人值守"意味着易受外界干扰。系统越复杂，抗外界干扰能力就越差。如果设计TA系统时，没有在满足测试目标的前提下，尽可能地简化设计，那么就会导致TA系统过于复杂，TA的后期维护成本也就过高。

- **TA Case的维护成本过高**。TA Case本质上就是代码。TA Case能不能工作(Work)，决定了测试的目的能不能达到。但是，TA Case仅仅能够工作是远远不够的，我们要对TA Case的质量提出要求。因为TA Case的质量直接决定TA Case后期的维护成本。通常来说，测试人员普遍缺乏编程经验，试图一下子就写出高质量TA Case的可能性是很低的。编程经验不足的人，很容易写出(1) 大段大段的重复代码 (2)互相依赖、结构混乱的代码块。软件开发中"Don't Repeat Your Self"和"高内聚，低耦合"等众所周知的准则，无时无刻不被TA Case实现人员违反着。在软件工程中，有一个未必精确但却引起广泛共鸣的[说法](http://rebrn.com/re/the-first-law-of-software-quality-868466/)：

    > 软件代码Bug的数量与代码长度的平方成正比，即 $Error = More\ Code ^2$。

    通过简单拷贝、模仿所堆积起来的TA Case，不仅功能不稳定，自身容易出现各种Bug，而且后期也是很难维护的。我曾经对某位同事的一份TA Case文件进行了重构。统计了一些简单的指标，对重构前和重构后的情况进行对比，如下表所示：

    | 量化指标      |    重构前 | 重构后  |
    | :-------- | --------:| :--: |
    | 测试用例文件总行数  | 238 |  126   |
    | 单行最大字符个数(不包括空格/Tab)   |   343 |  132  |
    | 单个函数的最大长度(行)      |    18 | 8  |
    | 单个函数的最大参数个数     |    9 | 4  |
	| 单个常量出现的最大次数     |    9 | 1  |
	| 导入的外部库      |    9 | 1  |
	| 封装的通用(Common)库函数      |    0 | 12  |


	重构带来了什么变化？举例来说，如果某个常量的值变了，原本我们需要寻找并修改9处，而现在只需要修改1处；原本我们没有封装任何通用的库函数，现在我们封装了12个可供其他Case调用的函数，而这有可能会(事实证明确实)大大减少其他Case的代码长度。试想，如果没有这次重构，后果会怎样？如果一个系统，数以百计的TA Case，都是类似上面这种重构前的状态，后期我们如何维护？对于软件来说，变化是常态。无论是软件需求的变化，还是软件实现的重构，抑或软件Bug的修复，都有可能需要TA Case去做适配和修改。如果每一次外部变动，都导致TA Case失败一大片，而且需要花费很大的成本才能修复失败的TA Case，那TA Case维护成本之高将让所有人都难以承受。


- **TA支撑库的维护成本过高**。一个完整的测试软件通常包含(1)TA Case (2)TA Library。TA Library，是由TA Case直接调用，并与被测软件实际交互的模块。本质上，所有自动化的工作是由TA Library来完成的，其质量至关重要。TA Library不稳定，将会对所有使用这个Library的TA Case的稳定性产生影响。站在维护的角度，TA Library自身的维护成本会在TA Case那里得到成倍的放大。一个精简的Library，总是比一个复杂的Library稳定可靠。TA Library应当在满足TA Case需求的前提下，做得尽可能简单。没有前期的高质量，就没有后期的低维护。我们意图用测试软件去测被测软件，那么**"打铁还需自身硬"**，测试软件自身的质量应该足够高。作为测试软件的核心模块，TA Library的质量更是重中之重。许多TA Library自身并没有经过严格的测试，事实上是很难承担起测试产品软件重任的。另外，对于任何软件来说，出现Bug并不可怕，可怕的是对Bug的**响应时间**太慢。TA Library的维护成本，部分地体现在TA Library对自身Bug的处理效率上，而这直接影响整个自动化测试工作的进度。从实际经验看，如果TA Library的Bug修复时间不是以小时(Hour)计，而是以天(Day)来计，那么使用者的体验就会很差，TA的效益也就大打折扣。

## 我们期望什么样的TA？

为什么TA有这么多好处，但是在许多实际项目中，其带来的收益却往往无法让人满意？笔者认为，与其去质疑TA的正确性，不如回到两个根本性问题上：(1) 我们期望什么样的TA? (2) 我们怎么样实现期望的TA？首先，从TA定位的角度回答第一个问题。在软件工程中，测试工作是为提升产品质量而存在的，其自身并不属于软件产品的一部分。同样，所有的TA Case和TA Library均属于辅助性的测试代码，不会发布给用户使用。其存在的价值只在于在软件发布前，尽可能地发现产品软件代码潜在的问题。笔者认为，简单(Simple)、可靠(Reliable)、可维护(Maintainable)和可读(Readable)的TA才是我们所需要的。
### 简单的TA
一个复杂的系统，往往意味着更多的工作量、更大的投入。而TA的辅助性质，决定了它不可能也不应该过于复杂。而且，简单是可靠、可维护、可读的基础。大道至简。那么，什么样的TA才是一个简单的TA呢？

- **TA测试系统尽可能简单**。TA测试系统由被测软件、测试软件(即TA Case +  TA Library)，以及运行这些软件所需的硬件设备共同构成。 一个复杂的TA测试系统，其收益往往不会高。这体现在两个方面，当系统复杂时，系统被测软件之外的模块出现问题的概率大大增加。这会严重影响TA的可信度；当系统复杂时，即使通过TA发现了软件问题，但是由于系统中的模块太多，软件问题的定位、解决和验证会花费很大的成本。笔者认为：

    > TA的收益与TA测试系统的复杂度成反比

    为了确保TA的收益，我们的测试系统应该尽可能简单。然而在实践中，结构庞大复杂的TA测试系统却普遍存在。造成这一现象的原因可能有两种。首先，被测软件所处的系统本身就很复杂，体现在外部依赖模块太多，并且模块之间难以解耦。系统设计是否满足"高内聚，低耦合"的原则，直接决定了系统的**可测性**(Testability)，也间接决定了系统的质量。从测试角度，一个可测性不好的系统，往往需要等到依赖的模块全部开发完成后，才能开始对目标模块进行测试。而此时的测试必然是基于复杂系统的测试。其次，测试人员希望搭建一个与用户应用场景一致的测试环境，以此来保证测试用例的覆盖度。这本身并没有错。覆盖度确实是测试很重要的一个指标。但是，如果这个系统是用来做自动化测试的，则存在问题。软件测试有许多阶段，例如单元测试-组件测试-功能测试-系统测试等，而"接近真实用户环境"只应当是对最后一个阶段，即"系统测试"的要求。根据经验：

    > 软件测试中，随着测试阶段(单元测试-组件测试-功能测试-系统测试)的推进，发现的Bug的解决成本呈**指数级**增长。

	这意味着，测试的资源应该更多地投入到早期测试阶段(单元测试、组件测试、功能测试)，以期更早地发现问题、节省成本。对于系统测试之前的测试阶段，不仅完全没有必要使用真实环境，而且应该在满足测试目的的情况下，尽可能地简化测试环境。

- **TA Library尽可能简单**。TA Library直接与被测系统交互，在自动化测试系统中处于中枢地位。TA Library在满足测试要求的情况下，代码量应该越小越好。成熟的测试自动化框架(例如[Robot Framework](http://robotframework.org/))、强大的高级编程语言(例如[Python](http://www.python.org/))，海量的第三方库(例如[Python第三方库](https://pypi.python.org/pypi))，为我们构建TA Library提供了充足的、可信赖的资源。我们应该充分利用已有的资源，快速、低成本地实现TA Library。

- **TA Case尽可能简单**。TA Case来源于需求/设计文档，是对验收性测试用例的具体实现。为了保证测试的覆盖度，我们可能需要考虑很多的场景。但就单个场景来说，TA Case不应该做除(1)触发测试步骤(2)验证测试结果之外的事情，并且，不同的Case之间应该实现代码最大程度的复用。TA Case的简洁性，不仅有利于提升自身的稳定性，而且有利于节省后期的维护成本。
### 可靠的TA
自身的可靠性对于TA至关重要，甚至可以说是TA的生命。可靠性有一个经验主义的衡量标准，即当TA Case失败时，我们有多大程度的自信，能够断定失败一定是由软件Bug(或者某些环境问题)而不是由TA自身造成的？我们应当追求**100%**的自信度。虽然很难做到，但是我们应当树立这样的目标，并为之努力。只有这样，TA的价值、测试的价值才能够得到充分体现。
### 可维护的TA
软件维护花费成本，却少有实际价值。TA作为辅助性的软件，其维护成本更应当尽可能降低。在软件的生命周期中，各种各样的变化都可能要求TA Case/TA Library做适配。我们希望TA能够**快速响应**这种变化，在较短的时间内能够适配完毕。
### 可读的TA
对于TA Case来说，我们增加了可读性的要求。可读性也有一个简单的衡量标准，那就是阅读TA Case是否像阅读需求文档一样轻松易懂？首先，这是可以做到的。从功能上讲，TA Case是对软件测试步骤的代码实现。测试步骤是用户需求的直接反映，并且通常是顺序执行的，不太可能包含复杂的逻辑。其次，这是应当做到的。TA Case的可读性，能够使得任何有相关专业背景知识的人，都能够很顺利地阅读TA Case和理解TA Case的执行结果，而这对于TA Case的使用和维护都有帮助。
## 我们怎样实现期望的TA？
我们从技术、流程、组织和个人四个维度，探讨怎样去实现我们所期望的，简单、可靠、可维护和可读的TA。
### 技术

- **充分使用Mock**。在软件测试中，Mock无处不在。所谓Mock，就是把被测对象所依赖的外部对象用模拟器(Simulator)替代，并用这些模拟器来测试被测对象。无论被测对象是一个函数，还是一个复杂的设备，模拟器都很实用，有时甚至是**不可或缺**的。以一个包含两个软件(设备)A和B的系统S为例。对系统S的测试应当属于系统测试的范畴，而对A和B的测试则属于功能测试的范畴。由于在系统测试中发现的Bug，比在功能测试中发现的Bug的解决成本要高得多。因此，**在进行系统测试前，我们务必要进行充分的功能测试，以保证能够在功能测试中发现的问题，尽量不要漏到系统测试中才被发现**。那么问题来了，如果我们要测试A，但是A无法在没有B的情况下工作，怎么办？注意到，我们不能拿B来测试A，因为B是未经测试、不可信的(B的测试本身也依赖A)。这时，我们就需要一个B的模拟器。开发这样一个模拟器需要成本，但是这种投入是值得的，为什么？

     - **模拟器易于实现**。本质上，这个模拟器需要模拟的不是B的全部功能，而只是模拟A与B之间的接口。现代系统设计的不二法则是"高内聚，低耦合"。低耦合，意味着A与B之间的接口不会很复杂。B的模拟器只要实现这样一个接口就可以了。注意到，

         > 模拟器的复杂度与被模拟对象真实的复杂度不存在正比关系。

	    通常，对于一个内部极其复杂的软件B，我们有可能只要开发一个轻量级的模拟器B就能够满足A的测试需求。反之亦然。由于模拟器的功能简单，因此通常易于实现、投入也低。

     - **模拟器加快测试进度**。模拟器一旦就绪，测试就可以开始。如果没有模拟器，测试被阻塞(Block)将是常态。在上面的例子中，A的每一个功能点完成后，都可以立即与模拟器B进行集成，而无须等待真实B对应功能的开发。只要模拟器B的开发严格遵从A-B间接口的规范，并由测试人员保证测试数据(样本)的正确性，那么与模拟器B的集成结果就足以验证A的功能。我们知道，测试工作开始得越早，软件问题发现得也就越早，修复软件问题的成本也就越低。所以，使用模拟器是一件既节省测试工作量、又改善测试效果的事情，可谓事半功倍。

     - **模拟器助力软件问题的定位和解决**。继续上面的例子。即使对A进行了充分地功能测试，我们仍然不能保证在后续的系统测试中，A不出现问题。如果在系统测试中，测试出A的功能问题，我们便需要对该问题进行修复。笔者认为：

         > 软件测试的各个阶段(单元测试-组件测试-功能测试-系统测试)，凡是在**当前**测试阶段所发现的软件Bug，一定能够在**上一个**测试阶段或**更早的**测试阶段中，通过修改或者增加一个测试用例来**复现**(Reproduce)。

         之所以A的功能问题没有全部在功能测试中被发现，与模拟器的可信度、测试用例的覆盖度和测试数据的准确度有关系。很多情况下，这是难以彻底避免的。有模拟器的好处在于，一旦系统测试中发现问题，我们很容易在模拟环境中复现该问题。这有助于快速地验证软件改动的正确性。如果系统测试中发现A的功能问题，那么功能测试的TA Case也应当做对应的修改。并且，只要软件改动能够通过修改后的功能测试TA Case的验证，那么在真实环境中对应的问题通常就会得到解决。这意味着，我们无须通过系统测试去验证我们的改动，而系统验证通常是周期长、效率低、反馈慢的。使用模拟器，软件问题修复的效率得到了提高。

-  **充分测试TA自身**。没有经过测试的软件，其可用性(Availability)存疑。同样，如果TA软件自身没有经过充分地测试，如何能够被用来测试产品软件的质量？可以说，TA自身的测试是极其必要的。TA Library(包括模拟器)由于其在测试系统中承上启下的地位，严格的测试更是必不可少。**只有充分的测试才能保证TA  Library的质量，才能保证其可用性**。

     - **将每一个来自TA Case的需求以UT的形式体现，然后再进行开发** 。TA Library功能简单、代码通常比较轻量，容易做单元测试(Unit Test, UT)，适合实践TDD(测试驱动开发)。TA Case是TA Library的需求方。对来自TA Case的每一个需求，首先将其转换成一个或多个UT Case。然后，我们的代码实现以对应的UT Case通过为目标。只要UT Case通过了，一般来说我们能保证TA Case的需求得到满足。UT的另外一个好处是执行速度非常快。代码每做一点改动，改动的效果就会从UT Case执行的结果中看出来。例如，我们开发的一个实现模拟器功能的TA Library，总共有近200个UT Case，在普通Linux虚拟机上，10秒钟左右就能执行完毕，给出反馈结果。完整的UT覆盖加快了开发速度、提高了开发质量。在半年多时间内，我们[Gitlab](http://gitlab.china.nsn-net.net/ta/nbs)项目一共有1800次提交，完成了186个Task，合并了192个Merge Request，发布了216个版本。这些数据背后，均得益于我们从一开始就坚持UT驱动开发，并持续改进我们的UT。当然，UT也有另一个好处，即确保后期的代码改动不破坏已有功能。

     - **在TA Library的开发中，使用Mock技术**。通常，TA Library是先于被测软件存在的。在没有被测软件的情况下，如何测试TA Library的功能？同样，我们需要Mock。还是基于上面的例子。为了测试A，我们需要开发一个B的模拟器。那么为了测试模拟器B的功能，我们反过来也需要对A进行Mock。这个Mock的A存在于模拟器B的单元测试中。我们知道，模拟器B相对真实A，是足够简单的。同理，相对模拟器B，此时的Mock A也必须足够简单。只有足够简单的东西，才足够稳定、可信赖。事实上，我们可能只需要直接调用一些第三方库，并输入若干样本数据就可以开发出Mock的A，以实现测试模拟器B的需求。

     - **对于每一个TA Case测出的问题，进行UT重现**。每一个TA Case测出的TA Library问题，一定能够通过修改或增加一个TA Library的UT Case来复现。基于修改或增加后的UT Case，我们去修复TA Library的问题。代码修复完成的标准，是新的UT Case通过。而新的UT Case一旦通过，我们通常可以断定TA Case发现的问题不会再出现。因此，我们只需要本地验证后，即可以放心地发布升级的TA Library版本，部署给测试人员使用，而无需发布一个Debug版本让测试人员去验证我们的修复效果。 基于这种流程，UT会变得越来越完善，后续的UT设计也会参考前面的经验教训，并引以为鉴。

     - **持续的重构和优化**。对任何软件开发来说，重构和优化只有进行时，没有完成时。重构是手段，优化是目的。需要强调的是，不要等到所有代码完成之后，再进行重构。重构应当与代码开发同时进行。写代码的过程，也是重构和优化代码的过程。TA Library和TA Case都应该被持续地重构和优化。
### 流程

- **TA 需求梳理**。需求梳理(Grooming)是软件工程中的重要一环，有助于业务、开发、测试多方对软件的功能和预期结果形成一致的理解。由于TA本质上也是一种软件活动，因此TA的需求梳理是不可或缺的。这意味着，
    > 一旦引入TA，软件测试的流程需要增加TA需求梳理这一环节。

    TA需求梳理需要澄清: (1) 哪些测试用例需要自动化？(2) 为了实现用例的自动化，需要测试人员做些什么? 需要TA Library提供什么样的支持？(3) TA Library/TA Case的实现计划和安排 (4) 风险估计。通常来说，TA需求梳理应该尽可能早地进行，可以和产品软件的需求梳理同步或稍微滞后，以给测试人员和TA Library开发人员提供充足的时间去实现代码。

- **TA 代码Review**。和所有的软件代码一样，测试代码也要经过Review才能被接受。测试代码的Review包含TA Library的Review和TA Case的Review。前者和软件代码的Review类似，在此不赘述。后者则需要着重强调一下。在Review过程中，我们特别强调TA Case的可读性，希望阅读TA Case就像阅读需求文档一样轻松、简单、明了。具体来说，我们强调Case风格的一致性和Case描述的完整性。对于风格的一致性，我们要求任何一个测试人员写出的任何一个测试Case，从代码角度，必须符合同样的、前后一致的代码规范。这有利于避免因风格差异造成的阅读理解困难。对于描述的完整性，我们要求每一个测试步骤的描述应当完整，以"主语-谓语-宾语"的形式，把测试步骤所做的事情讲清楚。一些测试框架，例如[Robot Framework](http://robotframework.org/)，为我们用自然语言自由地表达TA Case提供了技术支撑。在具体操作上，对要进入TA回归测试集的Case，我们通过**Room Meeting**的形式来Review。具体来说，把TA Case投影到大屏幕上，相关人员围坐在一起，对TA Case进行逐字逐句的分析和点评。这样的Review，既能收获到许多的意见(Comments)，也能够起到举一反三的效果。我们还有个小技巧。在Room Meeting Review时，不由作者本人，而**随机由其他人讲解**。作者本人只负责回应和记录Comments。这样能够很好的检验Case的可读性。因为如果Case的可读性足够好，那么任何稍有背景知识的人都应当能够在第一次阅读Case的时候就能基本理解Case的含义。

### 组织
- **软件设计**。软件的顶层设计，影响软件可测性，也影响TA的效果。从测试角度来说，软件的可测性是测试工作开展的前提条件。就TA而言，其对软件可测性有更高的要求。TA要求所有与被测对象交互的外部对象都是可以Mock(模拟)的。并且，对象之间接口的行为和数据是可预测的(Predictable)。实际上，这个要求与软件设计"高内聚，低耦合"的要求是**高度吻合**的。如果一个软件的正常行为依赖于一个无法被Mock的外部模块，那么这个软件的功能测试将受制于对应模块的实现。这将阻塞软件测试的进行，TA也一起受阻。

- **软件开发**。产品软件和TA Case，通常可以基于相同的需求/设计文档来实现。产品软件的开发是为了满足软件设计的目标，而TA Case的开发是为了检验产品软件的实现是否确实满足软件设计的目标。基于一致的目的， 软件的开发和TA Case的开发应该紧密地协同进行。需求或设计一旦发生变化，变化都应当及时地在软件开发和TA开发之间同步。

- **项目管理**。对于项目管理人员来，如期地、高质量地交付软件是根本目标。TA将测试工作提速, 并持续不断地**驱动**测试和开发人员去修复高频率、大强度测试过程中发现的所有问题。这提升了软件质量，降低了软件交付后的风险。从项目管理角度，对TA的投入是值得的。项目管理人员应当支持，尤其应当支持早期软件测试阶段的自动化。

- **CI**。伟大的软件公司一定有伟大的CI系统。CI输出的软件，应该以用户可用为目标。也就是说，CI须是面向交付的。一个面向交付的CI系统，要尽可能地将软件的各个测试和验证阶段逐步纳入CI的链条中来。软件工程的所有参与者都应该通过CI系统协同工作，实现共同的目标。对于任何一个测试阶段来说，进入CI的必要条件是测试能够实现自动化。TA是测试进CI的前提。另外，在实践中我们发现，由CI统一提供和维护标准化的、可靠的、私有的测试环境，比测试人员各自在本地搭建和维护测试环境要高效得多。当CI所承担的基础工作越来越多时，加大对CI的投入也是必要的。

### 个人

-  **测试人员更懂开发**。TA本质上是软件活动，是将测试工作以程序的形式实现并交给计算机去执行。我们发现，许多测试人员从未写过一行代码，但是在参与了一段时间的TA实践后，也能够完成数以百行的、可正常工作的测试代码，从而具备了一定的编程能力。另外，在编写、调试和运行TA Case的过程中，测试人员会遇到许多TA Case自身的问题，而这种问题本质上就是软件问题。解决这些问题的过程，也就是自身软件能力提升的过程。笔者认为，

    > TA的持续实践，无形中促进了测试工程师向测试开发工程师的蜕变。

	测试人员本身就懂系统，通过TA的实践又具备了一定的编程技能，尤其是系统编程(System Programming)技能。这将大大地促进测试人员的职业发展，并且对部门和公司的发展也是有利的。但是，测试人员需要意识到，编程能力的提升绝不是一朝一夕的事情，需要自我成长的意识和长期的实践，久久为功。"在游泳在学会游泳"。同理，在编程中学会编程，在持续地代码重构和优化中学会编程，在不断地探索、接触和运用新技术中学会编程。

- **开发人员更懂测试** 。与手动测试相比，TA使得测试人员和开发人员的工作关系更加紧密。对开发人员来说，与测试人员的协同工作，可以加深测试的理念(Mindset)。每一个软件开发人员都须明白，

    > 软件的开发应该以验收性测试通过、用户可使用为目的，没有通过测试检验的代码是没有价值的。

    有了牢固的测试理念，开发人员可能开发出更好的代码。通常来说，开发人员需要对软件功能的交付(Delivery)负责，而交付之前必要的环节就是软件测试。在TA的场景下，由于TA Case的目标与软件设计目标高度相关，并且CI提供测试环境、自动触发TA Case执行，开发人员完全可以自己去实现TA Case。在有TA Library的支撑下，开发人员实现TA Case没有技术难度。开发人员去实现TA Case和软件代码，并通过CI自动化地验证，将有效地节省开发与测试分割所带来的沟通成本和资源消耗。

## 结语
需要补充说明的是，不是所有手动测试都有必要进行自动化，也不是所有手动测试都容易实现自动化。做不做自动化？如何自动化？要结合实际情况，做出理性选择。本文的讨论限定于*必要且适合*做测试自动化的场景。无论如何，相比传统的手动测试，自动化测试确实是软件测试的一个重大变革。作为生产力的变革，测试自动化给测试自身带来了许多积极变化。另一方面，根据辩证法，生产关系要适应生产力的发展。软件测试生产力的提升必然对软件工程生产关系提出新的要求。因此，为了更好地发挥测试自动化的作用，无论是组织还是流程，都需要有一些积极的应变。我们要清醒地认识到，测试自动化的潜在效益绝非轻而易举可以获得，需要组织、流程的帮助，更需要测试人员自身的持续努力。

如果以历史演进的角度审视测试自动化，我们会发现一个有趣的现象。首先，测试自动化把测试人员从手动测试中解放了出来。然后，由持续集成系统自动地触发和执行测试，又再次解放了测试人员。倘若自动化测试用例由编程经验更丰富的开发人员去实现，是不是对测试人员的进一步解放？但是，可以确定，测试工作并非都可以被替代。解放后的测试人员，可以去设计更好、更完整的测试用例，去进行探索性测试，去向着更有挑战性的目标前进。
## 反馈与建议
- 邮箱: <shliangxiao@gmail.com>

